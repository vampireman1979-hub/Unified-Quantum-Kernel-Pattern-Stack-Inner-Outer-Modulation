import numpy as np
from qiskit import QuantumCircuit

# ============================================================
# Angle model
# ============================================================

def compute_angles(chi_value: float):
    decay = 20.0 * np.exp(-chi_value / 10_000.0)
    d = decay / 320.0
    theta = 2.0 * np.pi * d
    theta2 = theta / 2.0
    return theta, theta2


# ============================================================
# Base circuit
# ============================================================

def new_base_circuit():
    qc = QuantumCircuit(5)
    q0, q1, q2, q3, q4 = 0, 1, 2, 3, 4
    return qc, q0, q1, q2, q3, q4


# ============================================================
# Pattern Stack Layer (cleaned)
# ============================================================

def pattern_stack_kernel_layer(qc, chi_value: float):
    """
    Clean, deterministic version of your Pattern Stack kernel.
    Acts in-place on the existing circuit.
    """
    q0, q1, q2, q3, q4 = 0, 1, 2, 3, 4
    theta, theta2 = compute_angles(chi_value)

    # Phase 1: anchor + symmetry
    qc.h(q2)
    qc.cx(q2, q1)
    qc.cx(q2, q3)

    # Phase 2: inner modulation
    qc.rz(theta * 0.2, q1)
    qc.rz(-theta * 0.2, q3)
    qc.ry(theta * 0.15, q1)
    qc.ry(theta * 0.15, q3)

    # Phase 3: echo
    qc.cx(q1, q3)
    qc.cx(q3, q1)

    # Phase 4: divergence
    qc.ry(theta * 0.25, q1)
    qc.ry(-theta * 0.25, q3)

    # Phase 5: constraint
    qc.cx(q1, q3)
    qc.rz(theta * 0.1, q1)
    qc.rz(-theta * 0.1, q3)

    # Phase 6: outer coupling
    qc.cx(q1, q0)
    qc.cx(q3, q4)

    # Phase 7: outer shaping
    qc.rz(theta2 * 0.1, q0)
    qc.rz(theta2 * 0.1, q4)
    qc.ry(theta2 * 0.15, q0)
    qc.ry(theta2 * 0.15, q4)

    # Phase 8: final echo
    qc.cx(q0, q4)
    qc.cx(q4, q0)


# ============================================================
# Inner–Outer Modulation Layer (cleaned)
# ============================================================

def inner_outer_modulation_layer(qc, chi_value: float):
    q0, q1, q2, q3, q4 = 0, 1, 2, 3, 4
    theta, theta2 = compute_angles(chi_value)

    # Anchor entanglement
    qc.h(q2)
    qc.cx(q2, q1)
    qc.cx(q2, q3)

    # Inner modulation blocks
    qc.rx(theta * 0.15, q1)
    qc.rx(-theta * 0.15, q3)

    qc.ry(theta * 0.2, q1)
    qc.ry(theta * 0.2, q3)

    qc.rz(theta * 0.3, q1)
    qc.rz(theta * 0.3, q3)

    qc.cx(q1, q3)
    qc.cx(q3, q1)

    qc.cx(q1, q3)
    qc.rz(theta * 0.1, q1)
    qc.rz(-theta * 0.1, q3)

    qc.ry(theta * 0.25, q1)
    qc.rz(theta * 0.2, q3)

    qc.rz(np.pi, q1)
    qc.rz(-np.pi, q3)

    qc.h(q1); qc.h(q3)
    qc.cx(q1, q3); qc.cx(q3, q1)
    qc.h(q1); qc.h(q3)

    qc.rz(theta * 0.05, q1)
    qc.rz(-theta * 0.05, q3)

    qc.ry(theta * 0.1, q1)
    qc.ry(theta * 0.1, q3)

    # Propagation
    qc.cx(q1, q0)
    qc.cx(q3, q4)

    # Outer imprint
    qc.rz(theta2 * 0.1, q0)
    qc.rz(theta2 * 0.1, q4)

    qc.rx(theta2 * 0.15, q0)
    qc.rx(-theta2 * 0.15, q4)

    qc.ry(theta2 * 0.2, q0)
    qc.ry(theta2 * 0.2, q4)

    qc.cx(q0, q4)
    qc.cx(q4, q0)


# ============================================================
# Unified Kernel
# ============================================================

def unified_kernel(chi_value: float) -> QuantumCircuit:
    """
    Unified five-qubit kernel:
    1) Pattern Stack Layer
    2) Inner–Outer Modulation Layer
    """
    qc, q0, q1, q2, q3, q4 = new_base_circuit()

    pattern_stack_kernel_layer(qc, chi_value)
    inner_outer_modulation_layer(qc, chi_value)

    qc.measure_all()
    return qc
